using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using GalaxyExplorer;
using Microsoft.MixedReality.Toolkit;
using Microsoft.MixedReality.Toolkit.Input;
using Microsoft.MixedReality.Toolkit.Input.UnityInput;
using Microsoft.MixedReality.Toolkit.UI;
using Microsoft.MixedReality.Toolkit.Utilities.Solvers;
using Microsoft.MixedReality.Toolkit.WindowsMixedReality.Input;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using Debug = UnityEngine.Debug;

[Serializable]
public class UnityForceSolverEvent : UnityEvent<ForceSolver>
{
}

public class ForceSolver : Solver, IMixedRealityFocusHandler, IMixedRealityPointerHandler
{
    public enum State
    {
        None = 0,
        Root,
        Free,
        Dwell,
        Attraction,
        Manipulation,
    }

    private static int _dwellCounter;
    private static AudioSource _tractionBeamAudioSource;

    private ManipulationHandler _manipulationHandler;
    private Collider _attractionCollider;
    private Quaternion _rotationOffset, _previousRotation;
    private float _baseScale;
    private IAudioService _audioService;
    private AudioSource _activeAudioSource;
    private bool _forcePullToFrontOfCamera;
    private bool _forcePullToHandController => !_forcePullToFrontOfCamera;
    private Camera _mainCamera;
    private Coroutine _attractionDwellRoutine;
    private float _dwellTimer, _dwellForgivenessTimer;
    private readonly HashSet<IMixedRealityPointer> _focusers = new HashSet<IMixedRealityPointer>();
    
    

    // This should now be set through the GalaxyExplorerManager.ForcePullToCamFixedDistance property
    private float _offsetOnPullToCamera = 1f;

    public State ForceState { get; private set; }
    public State PreviousForceState { get; private set; }
    public bool EnableForce = true;
    [Range(0,10)]
    public float AttractionDwellDuration = 2f;

    public float AttractionDwellForgiveness = .5f;
    public Transform RootTransform;
    public ControllerTransformTracker ControllerTracker;
    public bool OffsetToObjectBoundsFromController = true;
    public ManipulationHandler ManipulationHandler;
    public Collider AttractionCollider;
    public float CurrentRelativeDwell => _dwellTimer;

    public UnityForceSolverEvent SetToRoot, SetToDwell, DwellCanceled, SetToAttract, SetToManipulate, SetToFree;

    protected override void Awake()
    {
        base.Awake();
        _mainCamera = Camera.main;

        _offsetOnPullToCamera = GalaxyExplorerManager.ForcePullToCamFixedDistance;

        _manipulationHandler = ManipulationHandler ? ManipulationHandler : GetComponentInChildren<ManipulationHandler>();
        Debug.Assert(_manipulationHandler != null, "Force Solver failed to find a manipulation handler");
        _attractionCollider = AttractionCollider ? AttractionCollider : GetComponentInChildren<Collider>();
        Debug.Assert(_attractionCollider != null, "Force Solver failed to find a attraction collider");

        _manipulationHandler.OnManipulationEnded.AddListener(OnManipulationEnd);

        if (ControllerTracker == null)
        {
            Debug.LogWarning(gameObject.name + " ForceSolver no controller tracker transform supplied will instantiate locally");
            var controllerTrackerObject = new GameObject(gameObject.name + " ForceSolver autogenerated controller tracker");
            ControllerTracker = controllerTrackerObject.AddComponent<ControllerTransformTracker>();
        }

        ControllerTracker.AllTrackingLost += OnControllersLost;
    }

    private void Start()
    {
        _audioService = MixedRealityToolkit.Instance.GetService<IAudioService>();
        StartRoot();
    }

    private void OnDestroy()
    {
        ControllerTracker.AllTrackingLost -= OnControllersLost;
    }

    private bool IsEyeGazed()
    {
        var provider = MixedRealityToolkit.InputSystem.EyeGazeProvider;
        if (provider.IsEyeGazeValid && provider.HitInfo.transform != null)
        {
            return provider.HitInfo.transform.IsChildOf(transform);
        }

        return false;
    }

    private void UpdateGoalsAttraction()
    {
        GoalScale = SolverHandler.TransformTarget.localScale;
        GoalPosition = SolverHandler.TransformTarget.position;
        if (_forcePullToHandController && OffsetToObjectBoundsFromController && !ControllerTracker.BothSides)
        {
            GoalPosition += GetOffsetPositionFromController();
        }
        if (_forcePullToHandController)
        {
            GoalRotation = SolverHandler.TransformTarget.rotation * _rotationOffset;
            UpdateWorkingRotationToGoal();
        }
        UpdateWorkingPositionToGoal();

        if (IsAttractionComplete())
        {
            StartFree();
        }
    }

    private bool IsAttractionComplete()
    {
        if (_forcePullToHandController)
        {
            if (!ControllerTracker.BothSides)
            {
                return Vector3.Distance(transform.position, SolverHandler.TransformTarget.position) <=
                       GetOffsetPositionFromController().magnitude;
            }
            else
            {
                //TODO implement check for when using both hands
            }
        }
        else if (_forcePullToFrontOfCamera)
        {
            return Vector3.Distance(WorkingPosition, GoalPosition) <= 0.1f;
        }

        return false;
    }

    private Vector3 GetOffsetPositionFromController()
    {
        var controllerFwd = ControllerTracker.transform.forward;
        var position = transform.position;
        var ray = new Ray(position - controllerFwd * 100, controllerFwd);
        var hit = _attractionCollider.Raycast(ray, out var hitInfo, 150);
        Debug.Assert(hit);
        return position - hitInfo.point;
    }

    private void StartRoot()
    {
        if (ForceState == State.Root)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Root;
        _manipulationHandler.enabled = false;
        SolverHandler.TransformTarget = RootTransform;
        OnStartRoot();
        SetToRoot?.Invoke(this);
    }

    protected virtual void OnStartRoot()
    {
    }

    private void StartDwell()
    {
        if (ForceState == State.Dwell)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Dwell;
        _manipulationHandler.enabled = false;
        SolverHandler.TransformTarget = ControllerTracker.ResolvedTransform;
        Debug.Assert(_attractionDwellRoutine == null);
        _attractionDwellRoutine = StartCoroutine(DwellCoroutine());
        OnStartDwell();
        SetToDwell?.Invoke(this);
    }

    protected virtual void OnStartDwell()
    {
    }

    public bool ForceSetDwellTimer(float time)
    {
        if (ForceState != State.Dwell)
        {
            return false;
        }
        _dwellTimer = time;
        return true;
    }

    private IEnumerator DwellCoroutine()
    {
        ++_dwellCounter;
        if (_dwellCounter == 1)
        {
            _audioService.PlayClip(AudioId.ForceDwell, out _tractionBeamAudioSource);
        }
        _dwellTimer = 0f;
        _dwellForgivenessTimer = 0f;
        while (ForceState == State.Dwell &&
               _dwellTimer < AttractionDwellDuration &&
               EnableForce &&
               _dwellForgivenessTimer < AttractionDwellForgiveness)
        {
            _dwellTimer += Time.deltaTime;
            if (_focusers.Count == 0)
            {
                _dwellForgivenessTimer += Time.deltaTime;
            }
            else
            {
                _dwellForgivenessTimer = 0f;
            }
            yield return null;
        }

        --_dwellCounter;
        Debug.Assert(_dwellCounter >= 0);
        if (ForceState == State.Dwell &&
            _focusers.Count > 0 &&
            EnableForce &&
            _dwellForgivenessTimer < AttractionDwellForgiveness)
        {
            StartAttraction();
        }
        else
        {
            OnDwellCanceled();
        }
    }

    protected virtual void OnDwellCanceled()
    {
        if (_dwellCounter == 0)
        {
            _tractionBeamAudioSource.Stop();
        }
        _attractionDwellRoutine = null;
        DwellCanceled?.Invoke(this);
        if (ForceState == State.Dwell)
        {
            switch (PreviousForceState)
            {
                
                case State.Root:
                    StartRoot();
                    break;
                
                case State.Free:
                    StartFree();
                    break;
                
                case State.None:
                case State.Manipulation:
                case State.Attraction:
                case State.Dwell:
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    private void StartAttraction(bool forcePullToFrontOfCamera = false)
    {
        if (ForceState == State.Dwell)
        {
            _attractionDwellRoutine = null;
        }
        if (ForceState == State.Attraction)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Attraction;
        if (forcePullToFrontOfCamera)
        {
            _forcePullToFrontOfCamera = true;
            SolverHandler.TransformTarget = _mainCamera.transform;
            SolverHandler.AdditionalOffset = Vector3.forward * _offsetOnPullToCamera;
        }
        else
        {
            _forcePullToFrontOfCamera = false;
            SolverHandler.TransformTarget = ControllerTracker.transform;
            SolverHandler.AdditionalOffset = Vector3.zero;
            var worldToPalmRotation = Quaternion.Inverse(SolverHandler.TransformTarget.rotation);
            _rotationOffset = worldToPalmRotation * transform.rotation;
        }
        _audioService.PlayClip(AudioId.ForcePull, out _activeAudioSource);
        OnStartAttraction();
        SetToAttract?.Invoke(this);
    }

    protected virtual void OnStartAttraction()
    {
    }

    private void StartManipulation()
    {
        if (ForceState == State.Manipulation)
        {
            return;
        }

        PreviousForceState = ForceState;
        ForceState = State.Manipulation;
        SolverHandler.TransformTarget = ControllerTracker.transform;
        _manipulationHandler.enabled = true;
        _audioService.PlayClip(AudioId.ManipulationStart, out _activeAudioSource);
        OnStartManipulation();
        SetToManipulate?.Invoke(this);
    }

    protected virtual void OnStartManipulation()
    {
    }

    private void StartFree()
    {
        PreviousForceState = ForceState;
        ForceState = State.Free;
        SolverHandler.TransformTarget = ControllerTracker.transform;
        _manipulationHandler.enabled = false;
        if (_activeAudioSource != null)
        {
            _activeAudioSource.Stop();
        }
        _audioService.PlayClip(AudioId.ManipulationEnd, out _activeAudioSource, transform);
        OnStartFree();
        SetToFree?.Invoke(this);
    }

    protected virtual void OnStartFree()
    {
    }

    private void OnManipulationEnd(ManipulationEventData _)
    {
        StartFree();
    }

    private void OnControllersLost()
    {
        switch (ForceState)
        {
            case State.Attraction:
                if (_forcePullToHandController)
                {
                    StartRoot();
                }
                break;
        }
    }

    private bool VerifyPointer(IMixedRealityPointer pointer)
    {
        // verify that the controller is a force attraction activator without tap
        if (pointer is IMixedRealityNearPointer)
        {
            return false;
        }
        var controller = pointer.Controller;
        return controller != null &&
               !(controller is WindowsMixedRealityGGVHand) &&
               (controller is IMixedRealityHand ||
               controller is WindowsMixedRealityController)
            ;
    }

    private bool IsGgvOrDesktopController(IMixedRealityController controller)
    {
                return  controller is WindowsMixedRealityGGVHand ||
                        controller is MouseController
# if UNITY_EDITOR
                        || controller is SimulatedArticulatedHand
#endif
                    ;
    }

    public override void SolverUpdate()
    {
        switch (ForceState)
        {
            case State.Root:
                SnapTo(RootTransform.position, RootTransform.rotation);
                break;
            
            case State.Dwell:
                if (PreviousForceState == State.Root)
                {
                    SnapTo(RootTransform.position, RootTransform.rotation);
                }
                break;

            case State.Free:
                // do nothing
                break;

            case State.Attraction:
                UpdateGoalsAttraction();
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnBeforeFocusChange(FocusEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public void OnFocusChanged(FocusEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public virtual void OnFocusEnter(FocusEventData eventData)
    {
        
        ////This part is for eye gaze tracing
//        // if the focus is the gaze then there is no controller
//        if (controller == null
//#if UNITY_EDITOR
//           || controller is SimulatedArticulatedHand
//#endif
//           ) { return; }
        /////

//        if (!EnableForce || 
//            ForceState != State.Root && ForceState != State.Dwell)
//        {
//            return;
//        }
//
//        if (!VerifyPointer(eventData.Pointer))
//        {
//            return;
//        }
//
//        ++_focusPointerCounter;
//        StartDwell();
        
        if (!EnableForce || !VerifyPointer(eventData.Pointer))
        {
            return;
        }

        _focusers.Add(eventData.Pointer);

        switch (ForceState)
        {
            case State.Root:
                StartDwell();
                break;
            
            case State.Dwell:
                break;
            
            case State.Free:
                if (!IsGgvOrDesktopController(eventData.Pointer.Controller))
                {
                    StartDwell();
                }
                break;
            
            case State.Manipulation:
            case State.Attraction:
                break;
            
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public virtual void OnFocusExit(FocusEventData eventData)
    {
        if (!EnableForce || !VerifyPointer(eventData.Pointer))
        {
            return;
        }

        _focusers.Remove(eventData.Pointer);
    }

    public void OnPointerUp(MixedRealityPointerEventData eventData)
    {
    }

    public void OnPointerDown(MixedRealityPointerEventData eventData)
    {
        switch (ForceState)
        {
            case State.Root: 
                if (eventData.Pointer is IMixedRealityNearPointer)
                {
                    StartManipulation();
                    _manipulationHandler.OnPointerDown(eventData);
                }
                else
                {
                    StartAttraction(IsGgvOrDesktopController(eventData.Pointer.Controller));
                }
                break;
            
            case State.Dwell:
                    StartManipulation();
                    _manipulationHandler.OnPointerDown(eventData);
                break;

            case State.Attraction:
            case State.Free:
                StartManipulation();
                _manipulationHandler.OnPointerDown(eventData);
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnPointerClicked(MixedRealityPointerEventData eventData)
    {
    }

    public void ResetToRoot()
    {
        StartRoot();
    }
}