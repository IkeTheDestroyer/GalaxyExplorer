using System;
using GalaxyExplorer;
using Microsoft.MixedReality.Toolkit;
using Microsoft.MixedReality.Toolkit.Input;
using Microsoft.MixedReality.Toolkit.Input.UnityInput;
using Microsoft.MixedReality.Toolkit.UI;
using Microsoft.MixedReality.Toolkit.Utilities.Solvers;
using Microsoft.MixedReality.Toolkit.WindowsMixedReality.Input;
using UnityEngine;
using UnityEngine.Events;
using Debug = UnityEngine.Debug;

[Serializable]
public class UnityForceSolverEvent : UnityEvent<ForceSolver>
{
}

public class ForceSolver : Solver, IMixedRealityFocusHandler, IMixedRealityPointerHandler
{
    public enum State
    {
        None = 0,
        Root,
        Free,
        Attraction,
        Manipulation,
    }

    private ManipulationHandler _manipulationHandler;
    private Collider _attractionCollider;
    private Quaternion _rotationOffset, _previousRotation;
    private float _baseScale;
    private IAudioService _audioService;
    private AudioSource _activeAudioSource;
    private bool _forcePullToFrontOfCamera;
    private bool _forcePullToHandController => !_forcePullToFrontOfCamera;
    private Camera _mainCamera;

    // This should now be set through the GalaxyExplorerManager.ForcePullToCamFixedDistance property
    private float _offsetOnPullToCamera = 1f;

    public State ForceState { get; private set; }
    public bool EnableForce = true;
    public Transform RootTransform;
    public ControllerTransformTracker ControllerTracker;
    public bool OffsetToObjectBoundsFromController = true;
    public Vector3 OffsetFromCameraOnNoControllerPosition;
    public ManipulationHandler ManipulationHandler;
    public Collider AttractionCollider;

    public UnityForceSolverEvent SetToRoot, SetToAttract, SetToManipulate, SetToFree;

    protected override void Awake()
    {
        base.Awake();
        _mainCamera = Camera.main;

        _offsetOnPullToCamera = GalaxyExplorerManager.ForcePullToCamFixedDistance;

        _manipulationHandler = ManipulationHandler ? ManipulationHandler : GetComponentInChildren<ManipulationHandler>();
        Debug.Assert(_manipulationHandler != null, "Force Solver failed to find a manipulation handler");
        _attractionCollider = AttractionCollider ? AttractionCollider : GetComponentInChildren<Collider>();
        Debug.Assert(_attractionCollider != null, "Force Solver failed to find a attraction collider");

        _manipulationHandler.OnManipulationEnded.AddListener(OnManipulationEnd);

        if (ControllerTracker == null)
        {
            Debug.LogWarning(gameObject.name + " ForceSolver no controller tracker transform supplied will instantiate locally");
            var controllerTrackerObject = new GameObject(gameObject.name + " ForceSolver autogenerated controller tracker");
            ControllerTracker = controllerTrackerObject.AddComponent<ControllerTransformTracker>();
        }

        ControllerTracker.AllTrackingLost += OnControllersLost;
    }

    private void Start()
    {
        _audioService = MixedRealityToolkit.Instance.GetService<IAudioService>();
        StartRoot();
    }

    private void OnDestroy()
    {
        ControllerTracker.AllTrackingLost -= OnControllersLost;
    }

    private void UpdateGoalsAttraction()
    {
        GoalScale = SolverHandler.TransformTarget.localScale;
        GoalPosition = SolverHandler.TransformTarget.position;
        if (_forcePullToHandController && OffsetToObjectBoundsFromController && !ControllerTracker.BothSides)
        {
            GoalPosition += GetOffsetPositionFromController();
        }
        if (_forcePullToHandController)
        {
            GoalRotation = SolverHandler.TransformTarget.rotation * _rotationOffset;
            UpdateWorkingRotationToGoal();
        }
        UpdateWorkingPositionToGoal();

        if (IsAttractionComplete())
        {
            StartFree();
        }
    }

    private bool IsAttractionComplete()
    {
        if (_forcePullToHandController)
        {
            if (!ControllerTracker.BothSides)
            {
                return Vector3.Distance(transform.position, SolverHandler.TransformTarget.position) <=
                       GetOffsetPositionFromController().magnitude;
            }
            else
            {
                //TODO implement check for when using both hands
            }
        }
        else if (_forcePullToFrontOfCamera)
        {
            return Vector3.Distance(WorkingPosition, GoalPosition) <= 0.1f;
        }

        return false;
    }

    private Vector3 GetOffsetPositionFromController()
    {
        var controllerFwd = ControllerTracker.transform.forward;
        var position = transform.position;
        var ray = new Ray(position - controllerFwd * 100, controllerFwd);
        var hit = _attractionCollider.Raycast(ray, out var hitInfo, 150);
        Debug.Assert(hit);
        return position - hitInfo.point;
    }

    private void StartRoot()
    {
        if (ForceState == State.Root)
        {
            return;
        }
        ForceState = State.Root;
        _manipulationHandler.enabled = false;
        SolverHandler.TransformTarget = RootTransform;
        OnStartRoot();
        SetToRoot?.Invoke(this);
    }

    protected virtual void OnStartRoot()
    {
    }

    private void StartAttraction(bool forcePullToFrontOfCamera = false)
    {
        ForceState = State.Attraction;
        if (forcePullToFrontOfCamera)
        {
            _forcePullToFrontOfCamera = true;
            SolverHandler.TransformTarget = _mainCamera.transform;
            SolverHandler.AdditionalOffset = Vector3.forward * _offsetOnPullToCamera;
        }
        else
        {
            _forcePullToFrontOfCamera = false;
            SolverHandler.TransformTarget = ControllerTracker.transform;
            SolverHandler.AdditionalOffset = Vector3.zero;
            var worldToPalmRotation = Quaternion.Inverse(SolverHandler.TransformTarget.rotation);
            _rotationOffset = worldToPalmRotation * transform.rotation;
        }
        _audioService.PlayClip(AudioId.ForcePull, out _activeAudioSource, transform);
        OnStartAttraction();
        SetToAttract?.Invoke(this);
    }

    protected virtual void OnStartAttraction()
    {
    }

    private void StartManipulation()
    {
        ForceState = State.Manipulation;
        SolverHandler.TransformTarget = ControllerTracker.transform;
        _manipulationHandler.enabled = true;
        _audioService.PlayClip(AudioId.ManipulationStart, out _activeAudioSource, transform);
        OnStartManipulation();
        SetToManipulate?.Invoke(this);
    }

    protected virtual void OnStartManipulation()
    {
    }

    private void StartFree()
    {
        ForceState = State.Free;
        SolverHandler.TransformTarget = ControllerTracker.transform;
        _manipulationHandler.enabled = false;
        if (_activeAudioSource != null)
        {
            _activeAudioSource.Stop();
        }
        _audioService.PlayClip(AudioId.ManipulationEnd, out _activeAudioSource, transform);
        OnStartFree();
        SetToFree?.Invoke(this);
    }

    protected virtual void OnStartFree()
    {
    }

    private void OnManipulationEnd(ManipulationEventData _)
    {
        StartFree();
    }

    private void OnControllersLost()
    {
        switch (ForceState)
        {
            case State.Attraction:
                if (_forcePullToHandController)
                {
                    StartRoot();
                }
                break;
        }
    }

    public override void SolverUpdate()
    {
        switch (ForceState)
        {
            case State.Root:
                SnapTo(RootTransform.position, RootTransform.rotation);
                break;

            case State.Free:
                // do nothing
                break;

            case State.Attraction:
                UpdateGoalsAttraction();
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnBeforeFocusChange(FocusEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public void OnFocusChanged(FocusEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public virtual void OnFocusEnter(FocusEventData eventData)
    {
        var controller = eventData.Pointer.Controller;
        // if the focus is the gaze then there is no controller
        if (controller == null
#if UNITY_EDITOR
           || controller is SimulatedArticulatedHand
#endif
           ) { return; }
        switch (ForceState)
        {
            case State.Root:
                if (EnableForce && controller.IsInPointingPose && controller.IsPositionAvailable)
                {
                    StartAttraction();
                }
                break;

            case State.Attraction:
                if (!controller.IsInPointingPose)
                {
                    StartManipulation();
                }
                break;

            case State.Free:
            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public virtual void OnFocusExit(FocusEventData eventData)
    {
    }

    public void OnPointerUp(MixedRealityPointerEventData eventData)
    {
    }

    public void OnPointerDown(MixedRealityPointerEventData eventData)
    {
        switch (ForceState)
        {
            case State.Root:
                var controller = eventData.Pointer.Controller;
                var isGgvOrDesktop =
                        controller is WindowsMixedRealityGGVHand ||
                        controller is MouseController
# if UNITY_EDITOR
                        || controller is SimulatedArticulatedHand
#endif
                    ;
                StartAttraction(isGgvOrDesktop);
                break;

            case State.Attraction:
            case State.Free:
                StartManipulation();
                _manipulationHandler.OnPointerDown(eventData);
                break;

            case State.Manipulation:
            case State.None:
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    public void OnPointerClicked(MixedRealityPointerEventData eventData)
    {
    }

    public void ResetToRoot()
    {
        StartRoot();
    }
}